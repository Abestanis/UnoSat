// *** AUTOGENERATED FILE - Do not edit manually! - Changes will be overwritten! *** //

#include "generated/receiver.h"
#include "generated/checksum.h"


bool parseMessage(BufferAccessor* buffer, MessageHandler* handler) {
    size_t availableSize = buffer->availableBytes(buffer);
    while (availableSize >= sizeof(TelemetryMessageHeader)) {
        uint8_t byteRead;
        if (!buffer->peek(buffer, &byteRead, sizeof(byteRead), 0) || byteRead != SYNC_BYTE_1 ||
            !buffer->peek(buffer, &byteRead, sizeof(byteRead), 1) || byteRead != SYNC_BYTE_2) {
            buffer->advance(buffer, 1);
            availableSize--;
            continue;
        }
        TelemetryMessageHeader header;
        if (!buffer->peek(buffer, &header, sizeof(header), 0)) {
            return false;
        }
        switch (header.type) {
        case TELEMETRY_DATA: {
            size_t dataSize = 16;
            if (buffer->availableBytes(buffer) < dataSize) {
                return false;
            }
            ms_t time;
            buffer->peek(buffer, &time, sizeof(time), sizeof(header));
            celsius_t temperature;
            buffer->peek(buffer, &temperature, sizeof(temperature), sizeof(header) + 4);
            static_assert(sizeof(float) == 4,
                    "float has an invalid size on this platform and can not be used");
            percent_t humidity;
            buffer->peek(buffer, &humidity, sizeof(humidity), sizeof(header) + 8);
            static_assert(sizeof(float) == 4,
                    "float has an invalid size on this platform and can not be used");
            pascal_t pressure;
            buffer->peek(buffer, &pressure, sizeof(pressure), sizeof(header) + 12);
            size_t checksumStartOffset =
                    sizeof(header.syncByte1) + sizeof(header.syncByte2) + sizeof(header.checksum);
            if (header.checksum != calculateChecksumFromBuffer(buffer,
                    sizeof(TelemetryMessageHeader) - checksumStartOffset + dataSize,
                    checksumStartOffset)) {
                handler->errorHandler(handler, CHECKSUM_ERROR);
                break;
            }
            buffer->advance(buffer, sizeof(header) + dataSize);
            handler->handleMessageData(handler, time, temperature, humidity, pressure);
            return true;
        }
        case TELEMETRY_LOG: {
            size_t dataSize = 0;
            ms_t time;
            if (!buffer->peek(buffer, &time, sizeof(time), sizeof(header) + dataSize)) {
                return false;
            }
            dataSize += sizeof(ms_t);
            uint8_t level;
            if (!buffer->peek(buffer, &level, sizeof(level), sizeof(header) + dataSize)) {
                return false;
            }
            dataSize += sizeof(uint8_t);
            uint16_t size;
            if (!buffer->peek(buffer, &size, sizeof(size), sizeof(header) + dataSize)) {
                return false;
            }
            dataSize += sizeof(uint16_t);
            if (size > 512) {
                handler->errorHandler(handler, DYNAMIC_SIZE_TOO_LARGE);
                break;
            }
            char message[size];
            if (!buffer->peek(buffer, &message, sizeof(message), sizeof(header) + dataSize)) {
                return false;
            }
            dataSize += size;
            size_t checksumStartOffset =
                    sizeof(header.syncByte1) + sizeof(header.syncByte2) + sizeof(header.checksum);
            if (header.checksum != calculateChecksumFromBuffer(buffer,
                    sizeof(TelemetryMessageHeader) - checksumStartOffset + dataSize,
                    checksumStartOffset)) {
                handler->errorHandler(handler, CHECKSUM_ERROR);
                break;
            }
            buffer->advance(buffer, sizeof(header) + dataSize);
            handler->handleMessageLog(handler, time, level, size, message);
            return true;
        }

        default:
            handler->errorHandler(handler, INVALID_MESSAGE);
        }
        buffer->advance(buffer, 2);
        availableSize -= 2;
    }
    return false;
}
